\chapter{本科毕业论文外文翻译}
%字数要求3000字


\heiti
摘要

\songti
当今世界，网络已被内容（content）的散布和获取所主导，而网络技术却仍然只言主机间连接而不及其它。%其它指物，其他指人。
为获取网络内容和服务，须要建立起一个从网络用户所关心的（内容）到网络中的位置的映射。%需要主观且物质，须要客观且抽象
我们提出内容为心网络（Content-Centric Networking~简称~CCN）。它以内容为原语——把网络位置与网络身份、安全和访问分离开来，用名字访问内容。我们从IP推演出适用于命名内容的路由算法。使用这些算法，我们可以使网络的可扩展性、安全性和性能同时达到要求。我们实现了我们的体系结构的基本框架，用安全文件下载和VoIP电话两个例子演示了网络的性能和可恢复性。

\heiti
类别和学科描述符

\songti
C.2.1~[计算机系统组织]：网络结构与设计；~C.2.2~[计算机系统组织]：网络协议

\heiti
通用术语

\songti
设计，实验，性能，安全



%===========================%
\section{引言}
今天的互联网背后的工程原理和体系结构创建于二十世纪六、七十年代。网络致力于解决的问题是资源共享的问题——远程使用如读卡器、高速磁带机甚至超级计算机等珍贵资源。这样产生的通信模型是一个仅仅存在于两台机器之间的对话模型，一台机器希望使用资源，另一台机器为前者提供资源。因此IP包含有两个地址，一个是发送方的，一个是目的地机器的，并且互联网上几乎所有的通信都包含TCP对话。

自包交换网络被创造的50年来，计算机及其附件已经成为廉价、普适的商品。互联网的连通性和低价的存储成本使得对海量新内容的访问成为可能——仅2008年就有500艾字节的信息被生产出来~[13]。人们在意的是互联网所承载的东西，而通信仍然在谈论这些东西都在哪些地方。

我们看到这个矛盾给用户带来三方面的（负面）影响。

\begin{description}
\item[可用性]为快速、可靠地访问内容，不仅须要如~CDN~和~P2P~网络这样繁冗的，预先设计好的，面向应用软件的机制，而且还会大幅增加带宽成本。
\item[安全性]对内容的信任这一概念被偷换为不那么可信的对物理位置和网络连接的的信任。
\item[位置迁就]建立从内容到物理位置的映射使网络服务的配置和实现工作都变得复杂。
\end{description}

解决这些问题的直接办法就是把网络中的“在哪里”（where）替换为“是什么”（what）。主机到主机对话是为了解决六十年代的问题而提出的抽象模型。对于如今的通信问题，我们认为命名数据（named data）是比命名主机（named hosts）更好的模型。我们提出内容为心网络（CCN），一个建立于命名数据之上的网络架构。即使是在CCN的最底层，我们也没有位置的概念——一个CCN包的“地址”是一个内容的名字，而不是这个内容的位置。不过，我们也保留了当年使~TCP/IP~简单、稳健、可扩展的那些设计决策。

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{images/narrow_waist}
  \caption{CCN~把网络协议栈中全局性的成分由IP换为了命名内容块} %不确定
  \label{narrow_waist}
\end{figure}

图~\ref{narrow_waist}~比较了~IP~和~CCN~协议栈。其中很多层都反映了双端约定；例如，第二层的成帧协议就反映了物理层上两端的约定，而第四层的传输协议就是一些信息生产者和消费者之间的约定。唯一一个需要全局约定的层就是第三层，即网络层。~IP~的成功在很大程度上要归功于它的网络层的简洁和它在网络第二层处提出的低要求，即：无状态，不可靠，无序，尽力交付。~CCN~的网络层（详见~\ref{sec:3}）与~IP~的网络层很相似且~CCN~对第二层的要求更少，这使得它非常具有吸引力。除此之外，~CCN~可以单独成层，放置于任何一层之上，包括放置于~IP~层之上。%这一段我不是很清楚，尤其是最后一句

CCN~与~IP~有几点关键性的不同。其中两点即策略和安全已经以新层的方式在协议栈中展示了出来。由于~CCN~与第二层的关系更为简单，它可以最大限度地利用众多同时存在的网络的连通性（如以太网，~3G~，蓝牙和~802.11~等等）。~CCN~的策略层（详见~\ref{sec:3.3}）为在不断变化的环境下最好地开发利用多种网络的连通性不断地做出细粒度、动态优化的选择。~CCN~确保的是内容本身的安全（详见~\ref{sec:5}），而不是内容走过的连接的安全。因此~CCN~没有许多基于主机网络的弱点，而不像~IP~网络那样深受其害。

我们在~\ref{sec:2}~至~\ref{sec:5}~中叙述了~CCN~的体系结构和运行方式。在~\ref{sec:6}~中我们评估了我们样板网络的性能。最后，在~\ref{sec:7}~和~\ref{sec:8}~中，我们讨论了相关工作并做出了结论。



%===========================%
\section{CCN~节点模型}
\label{sec:2}

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{images/packet_types}
  \caption{CCN~包的类型} 
  \label{packet_types}
\end{figure}

CCN~通信是由数据消费者驱动的。~CCN~包分为两类：兴趣包（Interest）和数据包（Data）（如图~\ref{packet_types}）。消费者通过向所有连通之处广播自己的兴趣包来索要内容。任何一个收到兴趣包并且拥有满足该兴趣包的数据的节点都可以用一个数据包来回应该兴趣包。数据包仅为回应一个兴趣包而生，并且数据包产生之后这个收到的兴趣包就被“消费”了。
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{数据包和兴趣包因此是一对一的。它们保持这严格的流平衡。~TCP~中有一个类似的流平衡，即数据包和~ack~包之间的平衡。这一平衡赋予了~TCP~可扩展性和强适应性~[20]。然而与~TCP~不同的是，~CCN~模型对于多对多多点递送同样奏效（详见~\ref{sec:3.1}）。}
因为兴趣包和数据包都用名字（name）来辨识内容，所以对同一个内容感兴趣的多个节点可以共享一个广播介质。其间只要使用标准的多播风暴抑制技术即可控制网络负荷~[3]。%不确定

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{images/name}
  \caption{名字示例} 
  \label{name}
\end{figure}

如果兴趣包中的内容名字（ContentName）是数据包中内容名字的前缀，那么我们称数据包“满足”了兴趣包。~CCN~名字是由若干名字部件（component）组成的不透明二元对象（如图~\ref{name}）。名字一般是结构化的，因此如果前缀匹配则意味着数据包的名字是兴趣包的名字的子树（详见~\ref{sec:3.2}）。~IP~使用了这种习惯来解析 <网络，子网，主机>这一层次结构。经验表明这样做既可以有效地将路由和转发状态结构化地集成，又可以支持快速查找。%极不确定
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{虽然~CCN~的名字是不定长的并且通常比~IP~地址要长，但是它们可以被高效地检索。一个~IP~地址的结构不是显式的，而是隐式地由节点的转发表决定的。因此，对~IP~查找使用现代~O(1)~哈希技术是十分困难的。所以~IP~查找通常使用~log(n)~的基数树检索或者并行但昂贵的~TCAMs~高端硬件。由于~CCN~的名字结构是显示的，内容名字可以很容易地被哈希，以便查找。}
这中匹配方式暗藏着这样一种可能性：内容尚未被生产出来，兴趣包就已经收到了——这使得发布者可以根据收到的数据请求实时地生产内容以回应兴趣。今天的网络中既有很多静态缓存着的数据，又有很多动态生成的数据，~CCN~灵活变化的名字机制使得它不论应对哪种数据都游刃有余。~CCN~名字还可以是上下文相关的，比如用~/ThisRoom/projector~与当前房间的投影仪交换信息，又如用~/Local/Friends~与本地（广播）环境上的任一好友交流。
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{这第二个例子会用到~CCN~签名机制产生的身份信息使好友们能用固定的名字约会而不是使用复杂的枚举或是探测算法。换言之，名字表示谈话的内容，而签名表示谈话者在上下文中的身份，如“本地的一个好友”。}

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{images/engine}
  \caption{CCN~转发引擎模型} 
  \label{engine}
\end{figure}

CCN~节点的基本运营方式与~IP~节点非常相似：当一个包到达一个~face~时，（节点）会先做一个最长名字匹配，后续操作由匹配结果而定。
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{这里原文中使用了英文单词~face~而非~interface，因为包不仅仅是在硬件接口之间被转发，也被路由器内的应用程序处理（详见~\ref{sec:6}）。}
图~\ref{engine}~展示了~CCN~的转发引擎。它有三个主要的数据结构：~FIB（Forwarding Information Base，转发中心），CS（Content Store，内容缓存）和~PIT（Pending Interest Table，待理兴趣表）。

FIB~用于将兴趣包转发给潜在数据源。它与~IP FIB~几乎相同，只是~CCN~的FIB会为每个兴趣包维护一个出口的列表，而~IP~的~FIB~仅需要为每个收到的包维护一个转发方向。这也反映了~CCN~在转发这方面并无限制这一事实。它允许多个数据源的存在，并允许并发地请求数据。

CS~与~IP~路由器的缓存大同小异，不过它们的置换策略略有不同。由于每个~IP~包仅仅属于一个点到点对话，它被转发了以后就不再具有任何意义了。因此~IP~路由器的做法是直接抛弃已转发的包并立即循环使用自己的缓存（MRU置换）。~CCN~包是幂等的，能够自我鉴别和自我认证，因此每一个~CCN~包都有被很多用户重用的潜力（如许多主机阅读同一份电子报纸或许多用户观看同一段~Youtube~视频）。为了使多个用户分享同一内容的概率最大化（这会带来上行带宽需求最小化和下行延时最小化等诸多裨益），~CCN~会尽可能多地储存到来的数据包（LRU或LFU置换）。

PIT~记录了数据包向数据源的转发记录，这样当数据包回到路由器时就可以按照~PIT~中的记录被转回至数据申请者（们）。在~CCN~中，只有数据包会被路由，并在它们走向潜在数据源的路上沿途撒下“面包屑”，以便匹配的数据将来沿着这些面包屑逆行，直到找到数据申请者（们）。每一个~PIT~表项就是这样一片面包屑。当一个~PIT~表项被用于转发数据包一次之后（即数据包“消费”了对应兴趣包），这个~PIT~表项就应该被抹去了。也有一些~PIT~表项一直都等不到匹配的数据包返回，这些表项最终必须因超时而被抹去（这时数据消费者如果仍然坚持想要那份数据，就有责任对那份数据重新表达兴趣）。

当兴趣包到达一个~face~时，一个最长名字匹配操作会被执行。匹配操作所用的索引结构（index）决定了机器会先在~CS~中寻找是否有匹配项，若没有则在~PIT~中寻找，若还没有则在~FIB中寻找。

如此，若本机的~CS~中已经有匹配兴趣包的数据包，则此数据包会从兴趣包到来的那个~face~被送出，然后兴趣包会被丢弃（因为它已经被满足了）。

如若不然，假如本机有一个~PIT~表项与兴趣包的内容名字完全匹配，则兴趣包到来的那个~face~会被加入到匹配的~PIT~表项中，然后那个兴趣包会被丢弃（因为这种情况表明对于相关数据的兴趣已经从本机向上行表达过了，现在需要确保的就是当对应数据包回到本机时必须向有新兴趣包到来的这个~face~抄送一份）。

若~PIT~中表项无一匹配，但是本机~FIB~中有匹配表项，那么这个兴趣包就必须根据匹配表项被转发。首先，在~FIB~对应表项的~face~列表中去除兴趣包到来的那个~face，若去除之后列表不为空的话，则将兴趣包转发给列表中的每一个~face。同时，一个新的~PIT~表项要被建立起来，这个表项的索引值是名字，内容是前面所说的~face~列表。

如果在~FIB~中都找不到与兴趣包匹配的表项，那么这个兴趣包会被直接丢弃（因为发生这种情况说明本机既没有现成的匹配数据，也不知道应该向哪里转发去寻找这个数据）。

相对于兴趣包而言，数据包的处理就要简单许多了。数据包不会被路由，它们只是简单地遵从沿路~PIT~表项的指示回到数据申请者（们）身边。当一个数据包到达时，也要做一次最长名字匹配。如果~CS~中有名字匹配则说明在此之前已经有数据包来过，所以这一个数据包就可以被丢弃了。如果有~PIT~匹配（可能不止一项），意味着此节点曾接收过对此数据包的请求。这个数据包可能先被验明正身（详见~\ref{sec:5.1}）然后被加入~CS~（即~index~列表中指向该数据包的指针被标记为~C-type）。随后，将所有匹配的~PIT~表项中的请求~face~做集合并，再减去数据包的到达~face，对所得集合中的每一个~face，发出这个数据包。如果存在~FIB~匹配，则意味着~PIT~中没有匹配，或者说此节点从未收到过关于此数据包的兴趣但是数据包确来到了此节点。这个数据包是一个“不请自来”的数据包，应当被丢弃。
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{“不请自来”的数据包可能由恶意行为产生，也可能是有多个数据源，或者单一数据源但有多条数据传播路径。如果是后两种情况，第一个到达节点的数据包会把兴趣包消费掉，因此后来的数据包将会找不到相应的~PIT~表项。不论是何种情况，为了保证流平衡以及帮助维持网络的平稳运行，“不请自来”的数据包都应当被丢弃。}

节点的内存要用于多路复用，~CCN CS~模型允许将内存同时当做网络缓存使用，这点与~IP~的~FIFP~缓存模型不同。这样一来，所有的节点都可以提供缓存，缓存的大小仅仅受节点本身资源丰匮程度和管理政策的限制。

用兴趣包换取数据包这种方法使~CCN~本能地适用于多点通信，这使它在高度动态变化的环境中仍然能轻松维持通信。任何一个对多个网络持有访问权的节点都可以成为网络间的内容路由。一个移动节点通过使用自身缓存可以连通两个原本不相连的网络区域，或通过间歇连接提供延时连通性。~CCN~以此提供对容断网络（Disruption Tolerant Networking）~[11]~的支持。兴趣包和数据包的交换在有本地连通性的地方即可进行。例如，两个同事可以用他们的笔记本电脑和自组无线网络在一个与外界网络隔绝的地方正常地分享文件等等。

%===========================%
\section{传输}
\label{sec:3}
CCN~传输被设计为在不可靠包递送服务之上运行，包括在连通性高度变化的移动和普适计算设备中运行。因此兴趣包和数据包都可能在传输中被丢失或损坏，被请求的数据也有可能暂时无法访问。为了提供可靠的传输服务，在合理时间内未被满足的~CCN~兴趣包必须重传。与~TCP~不同，~CCN~的发送者是无状态（stateless）的。在已表达的兴趣无响应的情况下，如果对相关数据仍有兴趣，那么数据的最终消费者（即对数据感兴趣的那个应用程序）应当负责重新表达兴趣。数据接收方的~strategy layer~（详见图~\ref{narrow_waist}）负责重传，同时负责决定用于表达兴趣的通信接口数、同一时间未被满足兴趣的最大容许量、不同兴趣之间的相对优先级等等。%存疑

底层的包交换网络可能会使包重复；~CCN~的多点散布模式（multipoint distribution）也可能造成包重复。根据~\ref{sec:2}~所述的节点运营机制，所有重复的包都会被丢弃。至此，虽然数据包的散步不会成环，但是兴趣包的散布却可能成环。这样，就有可能存在有的~face~收到了兴趣包，而实际上这个兴趣已经不存在了（被满足了）这样的局面。为了检测和预防此类事件，兴趣包中包含了一个随机数（nonce）。这样，从不同路径收到的重复的兴趣包就可以被丢弃了（见图~\ref{packet_types}）。

CCN~兴趣包使用~TCP ack~包使用的流控制和定序方法。%function 不知道我译得对不对
流控制在~\ref{sec:3.1}~中详述。定序在~\ref{sec:3.2}~中陈述。由于节点能见到与它的兴趣包匹配的所有数据这一点是有保障的，对兴趣包的回应时间和回应率可以由节点直接测量并用于决定对于某些名字前缀的兴趣包应该采取何种策略。这些内容将在~\ref{sec:3.3}~中详陈。

	\subsection{可靠性与流控制}
	\label{sec:3.1}
	一个兴趣包最多能带回一个数据包。这一基本规则保证了网络中的流平衡，使位于速度迥异的两个网络上的机器也能有效沟通。不过，与~TCP~中一样，可以将数据和请求合并。如果有多个兴趣包要发送，也不必等到第一个数据包回来消费了第一个兴趣包以后才发出第二个兴趣包，而是可以将多个兴趣包一起发出。兴趣包相当于~TCP~的窗口通告（window advertisement）。接收方可以通过调整它发出的兴趣包的数量来动态调整自己的窗口大小。我们在~\ref{sec:6.2}~中展示了这种方法的效果。%原文用了pipelining，但我不理解，此处有流水么？
	
	\subsection{编号}
	\label{sec:3.2}
	
	\subsection{高连通性，移动性及策略}
	\label{sec:3.3}


%===========================%
\section{路由}
\label{sec:4}
	\subsection{链路状态域内路由}
	\label{sec:4.1}
	
	\subsection{域间路由}
	\label{sec:4.2}

%===========================%
\section{内容为心安全}
\label{sec:5}
	\subsection{内容验证}
	\label{sec:5.1}
	
	\subsection{信任管理}
	\label{sec:5.2}
	
		\subsubsection{信任钥匙}
		\label{sec:5.2.1}
		
		\subsubsection{基于证据的安全}
		\label{sec:5.2.2}
	
	\subsection{内容保护与访问控制}
	\label{sec:5.3}
	
	\subsection{网络安全与措施强化}
	\label{sec:5.4}

%===========================%
\section{评估}
\label{sec:6}
	\subsection{数据传输的效率}
	\label{sec:6.1}
	
	\subsection{内容散布的效率}
	\label{sec:6.2}
	
	\subsection{VoCCN~与策略层}
	\label{sec:6.3}

%===========================%
\section{相关工作}
\label{sec:7}


%===========================%
\section{结论}
\label{sec:8}


%===========================%
\section{参考文献}
\def\tm{\leavevmode\hbox{$\rm {}^{TM}$}} %注册符 网上找的
[1] Project CCNx\tm. \url{http://www.ccnx.org}, Sep. 2009.

[2] M. Abadi. On SDSI’s Linked Local Name Spaces. \emph{Journal of Computer Security}, 6(1-2):3–21, October 1998.

[3] B. Adamson, C. Bormann, M. Handley, and J. Macker.
\emph{Multicast Negative-Acknowledgement (NACK) Building
Blocks}. IETF, November 2008. RFC 5401.

[4] W. Adjie-Winoto, E. Schwartz, H. Balakrishnan, and
J. Lilley. The Design and Implementation of an Intentional Naming System. \emph{SIGOPS Oper. Syst. Rev.}, 33(5):186–201, 1999.

[5] A. Anand, A. Gupta, A. Akella, S. Seshan, and S. Shenker. Packet Caches on Routers: The Implications of Universal Redundant Traffic Elimination. In \emph{SIGCOMM}, 2008.

[6] H. Balakrishnan, K. Lakshminarayanan, S. Ratnasamy, S. Shenker, I. Stoica, and M. Walfish. A Layered Naming Architecture for the Internet. In \emph{SIGCOMM}, 2004.

[7] M. Caesar, T. Condie, J. Kannan, K. Lakshminarayanan,
I. Stoica, and S. Shenker. ROFL: Routing on Flat Labels. In \emph{SIGCOMM}, 2006.

[8] D. Cheriton and M. Gritter. TRIAD: A New Next-Generation Internet Architecture, Jan 2000.

[9] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong. Freenet: A Distributed Anonymous Information Storage and Retrieval System. \emph{Lecture Notes in Computer Science}, 2009:46, 2001.

[10] C. M. Ellison, B. Frantz, B. Lampson, R. Rivest, B. M. Thomas, and T. Ylonen. \emph{SPKI Certificate Theory}, September 1999. RFC2693.

[11] S. Farrell and V. Cahill. \emph{Delay- and Disruption-Tolerant Networking}. Artech House Publishers, 2006.

[12] K. Fu, M. F. Kaashoek, and D. Mazières. Fast and secure distributed read-only file system. \emph{ACM Trans. Comput. Syst.}, 20(1):1–24, 2002.

[13] J. F. Gantz et al. IDC - The Expanding Digital Universe: A Forecast of Worldwide Inform ation Growth Through 2010. Technical report, March 2007.

[14] A. Gulbrandsen, P. Vixie, and L. Esibov. \emph{A DNS RR for specifying the location of services (DNS SRV)}. IETF - Network Working Group, The Internet Society, February 2000. RFC 2782.

[15] E. Guttman, C.Perkins, J. Veizades, and M. Day. \emph{Service Location Protocol}. IETF - Network Working Group, The Internet Society, June 1999. RFC 2608.

[16] IETF. RFC 2328 – OSPF Version 2.

[17] IETF. RFC 3787 – Recommendations for Interoperable IP
Networks using Intermediate System to Intermediate System (IS-IS).

[18] IETF. RFC 4971 – Intermediate System to Intermediate System (IS-IS) Extensions for Advertising Router Information.

[19] IETF. RFC 5250 – The OSPF Opaque LSA Option.

[20] V. Jacobson. Congestion Avoidance and Control. In
\emph{SIGCOMM}, 1988.

[21] V. Jacobson, R. Braden, and D. Borman. \emph{TCP Extensions for
High Performance}. IETF - Network Working Group, The
Internet Society, May 1992. RFC 1323.

[22] V. Jacobson, D. K. Smetters, N. Briggs, M. Plass, P. Stewart,
J. D. Thornton, and R. Braynard. VoCCN: Voice-over
Content-Centric Networks. In \emph{ReArch}, 2009.

[23] C. Kim, M. Caeser, and J. Rexford. Floodless in SEATTLE:
A Scalable Ethernet Architecture for Large Enterprises. In
\emph{SIGCOMM}, 2008.

[24] T. Koponen, M. Chawla, B.-G. Chun, A. Ermolinskiy, K. H.
Kim, S. Shenker, and I. Stoica. A Data-Oriented (and
Beyond) Network Architecture. In \emph{SIGCOMM}, 2007.

[25] J. Kubiatowicz et al. OceanStore: An architecture for
global-scale persistent storage. \emph{SIGPLAN Not.},
35(11):190–201, 2000.

[26] D. Mazières, M. Kaminsky, M. F. Kaashoek, and E. Witchel.
Separating Key Management from File System Security. In
\emph{SOSP}, 1999.

[27] R. C. Merkle. \emph{Secrecy, authentication, and public key
systems}. PhD thesis, 1979.

[28] R. Moskowitz and P. Nikander. \emph{Host Identity Protocol
Architecture}. IETF - Network Working Group, May 2006.
RFC 4423.

[29] B. Ohlman et al. First NetInf architecture description, April
2009. \url{http://www.4ward-project.eu/index.
php?s=file_download&id=39}.

[30] E. Osterweil, D. Massey, B. Tsendjav, B. Zhang, and
L. Zhang. Security Through Publicity. In \emph{HOTSEC}, 2006.

[31] B. C. Popescu, M. van Steen, B. Crispo, A. S. Tanenbaum,
J. Sacha, and I. Kuz. Securely replicated web documents. In
\emph{IPDPS}, 2005.

[32] R. L. Rivest and B. Lampson. SDSI - A Simple Distributed
Security Infrastructure. Technical report, MIT, 1996.

[33] M. Särelä, T. Rinta-aho, and S. Tarkoma. RTFM:
Publish/Subscribe Internetworking Architecture. In
\emph{ICT-MobileSummit}, 2008.

[34] D. K. Smetters and V. Jacobson. Securing network content,
October 2009. PARC Technical Report.

[35] I. Stoica, D. Adkins, S. Zhuang, S. Shenker, and S. Surana.
Internet Indirection Infrastructure. In \emph{SIGCOMM}, 2002.

[36] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and
H. Balakrishnan. Chord: A Scalable Peer-To-Peer Lookup
Service for Internet Applications. In \emph{SIGCOMM}, 2001.

[37] D. Wendlandt, D. Andersen, and A. Perrig. Perspectives: Improving SSH-style host authentication with multi-path
probing. In \emph{USENIX}, 2008.