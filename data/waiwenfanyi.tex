\chapter{本科毕业论文外文翻译}
%字数要求3000字


\heiti
摘要

\songti
当今世界，网络已被内容（content）的散布和获取所主导，而网络技术却仍然只言主机间连接而不及其它。%其它指物，其他指人。
为获取网络内容和服务，须要建立起一个从网络用户所关心的（内容）到网络中的位置的映射。%需要主观且物质，须要客观且抽象
我们提出内容为心网络（Content-Centric Networking~简称~CCN）。它以内容为原语——把网络位置与网络身份、安全和访问分离开来，用名字访问内容。我们从IP推演出适用于命名内容的路由算法。使用这些算法，我们可以使网络的可扩展性、安全性和性能同时达到要求。我们实现了我们的体系结构的基本框架，用安全文件下载和VoIP电话两个例子演示了网络的性能和可恢复性。

\heiti
类别和学科描述符

\songti
C.2.1~[计算机系统组织]：网络结构与设计；~C.2.2~[计算机系统组织]：网络协议

\heiti
通用术语

\songti
设计，实验，性能，安全



%===========================%
\section{引言}
今天的互联网背后的工程原理和体系结构创建于二十世纪六、七十年代。网络致力于解决的问题是资源共享的问题——远程使用如读卡器、高速磁带机甚至超级计算机等珍贵资源。这样产生的通信模型是一个仅仅存在于两台机器之间的对话模型，一台机器希望使用资源，另一台机器为前者提供资源。因此IP包含有两个地址，一个是发送方的，一个是目的地机器的，并且互联网上几乎所有的通信都包含TCP对话。

自包交换网络被创造的50年来，计算机及其附件已经成为廉价、普适的商品。互联网的连通性和低价的存储成本使得对海量新内容的访问成为可能——仅2008年就有500艾字节的信息被生产出来~[13]。人们在意的是互联网所承载的东西，而通信仍然在谈论这些东西都在哪些地方。

我们看到这个矛盾给用户带来三方面的（负面）影响。

\begin{description}
\item[可用性]为快速、可靠地访问内容，不仅须要如~CDN~和~P2P~网络这样繁冗的，预先设计好的，面向应用软件的机制，而且还会大幅增加带宽成本。
\item[安全性]对内容的信任这一概念被偷换为不那么可信的对物理位置和网络连接的的信任。
\item[位置迁就]建立从内容到物理位置的映射使网络服务的配置和实现工作都变得复杂。
\end{description}

解决这些问题的直接办法就是把网络中的“在哪里”（where）替换为“是什么”（what）。主机到主机对话是为了解决六十年代的问题而提出的抽象模型。对于如今的通信问题，我们认为命名数据（named data）是比命名主机（named hosts）更好的模型。我们提出内容为心网络（CCN），一个建立于命名数据之上的网络架构。即使是在CCN的最底层，我们也没有位置的概念——一个CCN包的“地址”是一个内容的名字，而不是这个内容的位置。不过，我们也保留了当年使~TCP/IP~简单、稳健、可扩展的那些设计决策。

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{images/narrow_waist}
  \caption{CCN~把网络协议栈中全局性的成分由IP换为了命名内容块} %不确定
  \label{narrow_waist}
\end{figure}

图~\ref{narrow_waist}~比较了~IP~和~CCN~协议栈。其中很多层都反映了双端约定；例如，第二层的成帧协议就反映了物理层上两端的约定，而第四层的传输协议就是一些信息生产者和消费者之间的约定。唯一一个需要全局约定的层就是第三层，即网络层。~IP~的成功在很大程度上要归功于它的网络层的简洁和它在网络第二层处提出的低要求，即：无状态，不可靠，无序，尽力交付。~CCN~的网络层（详见~\ref{sec:3}）与~IP~的网络层很相似且~CCN~对第二层的要求更少，这使得它非常具有吸引力。除此之外，~CCN~可以单独成层，放置于任何一层之上，包括放置于~IP~层之上。%这一段我不是很清楚，尤其是最后一句

CCN~与~IP~有几点关键性的不同。其中两点即策略和安全已经以新层的方式在协议栈中展示了出来。由于~CCN~与第二层的关系更为简单，它可以最大限度地利用众多同时存在的网络的连通性（如以太网，~3G~，蓝牙和~802.11~等等）。~CCN~的策略层（详见~\ref{sec:3.3}）为在不断变化的环境下最好地开发利用多种网络的连通性不断地做出细粒度、动态优化的选择。~CCN~确保的是内容本身的安全（详见~\ref{sec:5}），而不是内容走过的连接的安全。因此~CCN~没有许多基于主机网络的弱点，而不像~IP~网络那样深受其害。

我们在~\ref{sec:2}~至~\ref{sec:5}~中叙述了~CCN~的体系结构和运行方式。在~\ref{sec:6}~中我们评估了我们样板网络的性能。最后，在~\ref{sec:7}~和~\ref{sec:8}~中，我们讨论了相关工作并做出了结论。



%===========================%
\section{CCN~节点模型}
\label{sec:2}

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{images/packet_types}
  \caption{CCN~包的类型} 
  \label{packet_types}
\end{figure}

CCN~通信是由数据消费者驱动的。~CCN~包分为两类：兴趣包（Interest）和数据包（Data）（如图~\ref{packet_types}）。消费者通过向所有连通之处广播自己的兴趣包来索要内容。任何一个收到兴趣包并且拥有满足该兴趣包的数据的节点都可以用一个数据包来回应该兴趣包。数据包仅为回应一个兴趣包而生，并且数据包产生之后这个收到的兴趣包就被“消费”了。
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{数据包和兴趣包因此是一对一的。它们保持这严格的流平衡。~TCP~中有一个类似的流平衡，即数据包和~ack~包之间的平衡。这一平衡赋予了~TCP~可扩展性和强适应性~[20]。然而与~TCP~不同的是，~CCN~模型对于多对多多点递送同样奏效（详见~\ref{sec:3.1}）。}
因为兴趣包和数据包都用名字（name）来辨识内容，所以对同一个内容感兴趣的多个节点可以共享一个广播介质。其间只要使用标准的多播风暴抑制技术即可控制网络负荷~[3]。%不确定

如果兴趣包中的内容名字（ContentName）是数据包中内容名字的前缀，那么我们称数据包“满足”了兴趣包。~CCN~名字是由若干（显式确定数量的）名字部件（component）组成的不透明二元对象（如图~\ref{name}）。名字一般是结构化的，因此如果前缀匹配则意味着数据包的名字是兴趣包的名字的子树（详见~\ref{sec:3.2}）。~IP~使用了这种习惯来解析 <网络，子网，主机>这一层次结构。经验表明这样做既可以有效地将路由和转发状态结构化地集成，又可以支持快速查找。%极不确定
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{虽然~CCN~的名字是不定长的并且通常比~IP~地址要长，但是它们可以被高效地检索。一个~IP~地址的结构不是显式的，而是隐式地由节点的转发表决定的。因此，对~IP~查找使用现代~O(1)~哈希技术是十分困难的。所以~IP~查找通常使用~log(n)~的基数树检索或者并行但昂贵的~TCAMs~高端硬件。由于~CCN~的名字结构是显示的，内容名字可以很容易地被哈希，以便查找。}
这中匹配方式暗藏着这样一种可能性：内容尚未被生产出来，兴趣包就已经收到了——这使得发布者可以根据收到的数据请求实时地生产内容以回应兴趣。今天的网络中既有很多静态缓存着的数据，又有很多动态生成的数据，~CCN~灵活变化的名字机制使得它不论应对哪种数据都游刃有余。~CCN~名字还可以是上下文相关的，比如用~/ThisRoom/projector~与当前房间的投影仪交换信息，又如用~/Local/Friends~与本地（广播）环境上的任一好友交流。
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{这第二个例子会用到~CCN~签名机制产生的身份信息使好友们能用固定的名字约会而不是使用复杂的枚举或是探测算法。换言之，名字表示谈话的内容，而签名表示谈话者在上下文中的身份，如“本地的一个好友”。}

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{images/engine}
  \caption{CCN~转发引擎模型} 
  \label{engine}
\end{figure}

CCN~节点的基本运营方式与~IP~节点非常相似：当一个包到达一个~face~时，（节点）会先做一个最长名字匹配，后续操作由匹配结果而定。
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{这里原文中使用了英文单词~face~而非~interface，因为包不仅仅是在硬件接口之间被转发，也被路由器内的应用程序处理（详见~\ref{sec:6}）。}
图~\ref{engine}~展示了~CCN~的转发引擎。它有三个主要的数据结构：~FIB（Forwarding Information Base，转发中心），CS（Content Store，内容缓存）和~PIT（Pending Interest Table，待理兴趣表）。

FIB~用于将兴趣包转发给潜在数据源。它与~IP FIB~几乎相同，只是~CCN~的FIB会为每个兴趣包维护一个出口的列表，而~IP~的~FIB~仅需要为每个收到的包维护一个转发方向。这也反映了~CCN~在转发这方面并无限制这一事实。它允许多个数据源的存在，并允许并发地请求数据。

CS~与~IP~路由器的缓存大同小异，不过它们的置换策略略有不同。由于每个~IP~包仅仅属于一个点到点对话，它被转发了以后就不再具有任何意义了。因此~IP~路由器的做法是直接抛弃已转发的包并立即循环使用自己的缓存（MRU置换）。~CCN~包是幂等的，能够自我鉴别和自我认证，因此每一个~CCN~包都有被很多用户重用的潜力（如许多主机阅读同一份电子报纸或许多用户观看同一段~Youtube~视频）。为了使多个用户分享同一内容的概率最大化（这会带来上行带宽需求最小化和下行延时最小化等诸多裨益），~CCN~会尽可能多地储存到来的数据包（LRU或LFU置换）。

PIT~记录了数据包向数据源的转发记录，这样当数据包回到路由器时就可以按照~PIT~中的记录被转回至数据申请者（们）。在~CCN~中，只有数据包会被路由，并在它们走向潜在数据源的路上沿途撒下“面包屑”，以便匹配的数据将来沿着这些面包屑逆行，直到找到数据申请者（们）。每一个~PIT~表项就是这样一片面包屑。当一个~PIT~表项被用于转发数据包一次之后（即数据包“消费”了对应兴趣包），这个~PIT~表项就应该被抹去了。也有一些~PIT~表项一直都等不到匹配的数据包返回，这些表项最终必须因超时而被抹去（这时数据消费者如果仍然坚持想要那份数据，就有责任对那份数据重新表达兴趣）。

当兴趣包到达一个~face~时，一个最长名字匹配操作会被执行。匹配操作所用的索引结构（index）决定了机器会先在~CS~中寻找是否有匹配项，若没有则在~PIT~中寻找，若还没有则在~FIB中寻找。

如此，若本机的~CS~中已经有匹配兴趣包的数据包，则此数据包会从兴趣包到来的那个~face~被送出，然后兴趣包会被丢弃（因为它已经被满足了）。

如若不然，假如本机有一个~PIT~表项与兴趣包的内容名字完全匹配，则兴趣包到来的那个~face~会被加入到匹配的~PIT~表项中，然后那个兴趣包会被丢弃（因为这种情况表明对于相关数据的兴趣已经从本机向上行表达过了，现在需要确保的就是当对应数据包回到本机时必须向有新兴趣包到来的这个~face~抄送一份）。

若~PIT~中表项无一匹配，但是本机~FIB~中有匹配表项，那么这个兴趣包就必须根据匹配表项被转发。首先，在~FIB~对应表项的~face~列表中去除兴趣包到来的那个~face，若去除之后列表不为空的话，则将兴趣包转发给列表中的每一个~face。同时，一个新的~PIT~表项要被建立起来，这个表项的索引值是名字，内容是前面所说的~face~列表。

如果在~FIB~中都找不到与兴趣包匹配的表项，那么这个兴趣包会被直接丢弃（因为发生这种情况说明本机既没有现成的匹配数据，也不知道应该向哪里转发去寻找这个数据）。

相对于兴趣包而言，数据包的处理就要简单许多了。数据包不会被路由，它们只是简单地遵从沿路~PIT~表项的指示回到数据申请者（们）身边。当一个数据包到达时，也要做一次最长名字匹配。如果~CS~中有名字匹配则说明在此之前已经有数据包来过，所以这一个数据包就可以被丢弃了。如果有~PIT~匹配（可能不止一项），意味着此节点曾接收过对此数据包的请求。这个数据包可能先被验明正身（详见~\ref{sec:5.1}）然后被加入~CS~（即~index~列表中指向该数据包的指针被标记为~C-type）。随后，将所有匹配的~PIT~表项中的请求~face~做集合并，再减去数据包的到达~face，对所得集合中的每一个~face，发出这个数据包。如果存在~FIB~匹配，则意味着~PIT~中没有匹配，或者说此节点从未收到过关于此数据包的兴趣但是数据包确来到了此节点。这个数据包是一个“不请自来”的数据包，应当被丢弃。
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{“不请自来”的数据包可能由恶意行为产生，也可能是有多个数据源，或者单一数据源但有多条数据传播路径。如果是后两种情况，第一个到达节点的数据包会把兴趣包消费掉，因此后来的数据包将会找不到相应的~PIT~表项。不论是何种情况，为了保证流平衡以及帮助维持网络的平稳运行，“不请自来”的数据包都应当被丢弃。}

节点的内存要用于多路复用，~CCN CS~模型允许将内存同时当做网络缓存使用，这点与~IP~的~FIFP~缓存模型不同。这样一来，所有的节点都可以提供缓存，缓存的大小仅仅受节点本身资源丰匮程度和管理政策的限制。

用兴趣包换取数据包这种方法使~CCN~本能地适用于多点通信，这使它在高度动态变化的环境中仍然能轻松维持通信。任何一个对多个网络持有访问权的节点都可以成为网络间的内容路由。一个移动节点通过使用自身缓存可以连通两个原本不相连的网络区域，或通过间歇连接提供延时连通性。~CCN~以此提供对容断网络（Disruption Tolerant Networking）~[11]~的支持。兴趣包和数据包的交换在有本地连通性的地方即可进行。例如，两个同事可以用他们的笔记本电脑和自组无线网络在一个与外界网络隔绝的地方正常地分享文件等等。

%===========================%
\section{传输}
\label{sec:3}
CCN~传输被设计为在不可靠包递送服务之上运行，包括在连通性高度变化的移动和普适计算设备中运行。因此兴趣包和数据包都可能在传输中被丢失或损坏，被请求的数据也有可能暂时无法访问。为了提供可靠的传输服务，在合理时间内未被满足的~CCN~兴趣包必须重传。与~TCP~不同，~CCN~的发送者是无状态（stateless）的。在已表达的兴趣无响应的情况下，如果对相关数据仍有兴趣，那么数据的最终消费者（即对数据感兴趣的那个应用程序）应当负责重新表达兴趣。数据接收方的~strategy layer~（详见图~\ref{narrow_waist}）负责重传，同时负责决定用于表达兴趣的通信接口数、同一时间未被满足兴趣的最大容许量、不同兴趣之间的相对优先级等等。%存疑

底层的包交换网络可能会使包重复；~CCN~的多点散布模式（multipoint distribution）也可能造成包重复。根据~\ref{sec:2}~所述的节点运营机制，所有重复的包都会被丢弃。至此，虽然数据包的散步不会成环，但是兴趣包的散布却可能成环。这样，就有可能存在有的~face~收到了兴趣包，而实际上这个兴趣已经不存在了（被满足了）这样的局面。为了检测和预防此类事件，兴趣包中包含了一个随机数（nonce）。这样，从不同路径收到的重复的兴趣包就可以被丢弃了（见图~\ref{packet_types}）。

CCN~兴趣包使用~TCP ack~包使用的流控制和定序方法。%function 不知道我译得对不对
流控制在~\ref{sec:3.1}~中详述。定序在~\ref{sec:3.2}~中陈述。由于节点能见到与它的兴趣包匹配的所有数据这一点是有保障的，对兴趣包的回应时间和回应率可以由节点直接测量并用于决定对于某些名字前缀的兴趣包应该采取何种策略。这些内容将在~\ref{sec:3.3}~中详陈。

%...............................................................%
\subsection{可靠性与流控制}
\label{sec:3.1}
一个兴趣包最多能带回一个数据包。这一基本规则保证了网络中的流平衡，使位于速度迥异的两个网络上的机器也能有效沟通。不过，与~TCP~中一样，可以将数据和请求合并。如果有多个兴趣包要发送，也不必等到第一个数据包回来消费了第一个兴趣包以后才发出第二个兴趣包，而是可以将多个兴趣包一起发出。兴趣包相当于~TCP~的窗口通告（window advertisement）。接收方可以通过调整它发出的兴趣包的数量来动态调整自己的窗口大小。我们在~\ref{sec:6.2}~中展示了这种流水化的效果。由于每一个~CCN~包都是独立命名的，这条流水线不会因为有的包丢失了而堵塞——~TCP SACK~技术所做的事情是~CCN~的本能之一。

在大型网络中，~TCP~对话端对端的本性决定了一个事实：即使每一个对话都保持着流平衡，发送方和接收方之间还是有很多地方会因为会话的汇聚（aggregation）而发生拥塞（congestion）。%拥塞的产生原因有三种：speed mismatch, aggregation, confluence
这种拥塞的后果是包的延时和丢失。对此，~TCP~的解决办法是让端点动态调整窗口大小，使汇聚流量低于发生拥塞的标准~[20]。之所以需要这样的流控制方法，其根本原因就在于~TCP~的流平衡是端对端的。在~CCN~中，所有通信都是基于本地的，所以发送方和接收方之间没有一点是不处于平衡状态上的。由于~CCN~的每一跳都在维持流平衡，就没有必要再用其它的技术去控制传输路径中的拥塞了。这与逐跳流控制（hop-by-hop flow control）是不同的。逐跳流控制使用相邻节点间背压（backpressure）来调整连续流的速率；~CCN~则没有~FIFO~队列，只有~LRU~缓存。这一设计可以拆解逐跳反馈形成的环，也可以一只振荡。（我们将在未来的一篇论文中详细讨论这个问题）

	
%...............................................................%	
\subsection{定序}
\label{sec:3.2}
在一个~TCP~对话中，数据的辨识要依靠序列号。相比序列号而言，~CCN~需要一些更复杂的东西：~CCN~的消费者们要从海量的数据之中申请一份，并且众多的消费者还可能共享同样的数据。~CCN~对数据的定位和分享依靠的是结构化的、聚合而成的名字。这些名字并不仅仅是一场转瞬即逝的对话中使用到的临时序列号。组成这些名字的至少部分部件是人们可读、可理解的，并且反应了数据的来历信息。虽说~CCN~的名字拥有这些内涵，当它们出现在兴趣包里的时候，它们的通信功能跟~TCP ACK~的功能是一模一样的：道明接受者需要的下一个数据。

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{images/name}
  \caption{名字示例} 
  \label{name}
\end{figure}

在我们细说数据的辨识机制以前，让我们先来谈谈~CCN~的名字。如前文所说，名字是结构化的；每一个名字都由若干个名字部件（component）组成。每个名字部件又是由若干个八位字节任意数组成的。在此，八位字节任意数是一种对~CCN~通信无影响的变长二进制数。名字必须对协议栈中的高层有意义，但是传输本身不对名字加任何额外的限制，只是要求名字必须结构化，必须由部件组成就够了。整数或其它复杂数值的二进制编码可以直接做名字部件使用，无须专为传输需要转化为文本。名字部件甚至可以出于安全需要而被加密。为了表示方便，我们用类似~URI~的格式书写名字，并用~\slash~分隔各个名字部件（如图~\ref{name}），但是这些分隔符不是名字的一部分，在编码时也不会被放入包内。图中例子展示了~CCN~应用层面上目前使用的记录内容当下的发展状态的方法（一个版本标记，~\_v~编码后是~FD，其后跟着一个整数版本号）和分段方法（一个分段编号，~\_s~编码后是~00，其后跟着的整数值可能是块号，可能是字节号，也可能是该包中视频的第一帧的帧号）。每一个数据包的名字的最后一个部件隐式地包含了一个对该包的~SHA256~摘要。
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{摘要部件是可以计算得出的，所以它并不会被传输。文摘的存在可以使兴趣包准确无歧义地指代数据。} %存疑

兴趣包可以准确地言明它需要什么数据，然而在大多数情况下，下一个需要的数据的全名是未知的，所以消费者根据已知的名字采用“相对命名”法来表达兴趣。这样的做法之所以可行，是由于~CCN~名字树完全可以是有序的（子树按词典编撰顺序排列），从而可以用诸如“下一个”、“上一个”之类的词语来无歧义地表示关系而完全不需要知道名字的语义。

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{images/name_tree}
  \caption{名字树遍历} 
  \label{name_tree}
\end{figure}

下面举例说明。图~\ref{name_tree}~中展示了名字树中与图~\ref{name}~关联的部分。如果一个应用程序想要展示最新版视频，它就会表达这样一个兴趣：~\url{/parc.com/ videos/WidgetA.mpg}~\emph{RightmostChild}。在发送方就会执行如图~\ref{name_tree}~中高亮的遍历，
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{默认的遍历规则是\emph{LeftmostChild}}
找到该视频的第二个版本的第一段。一旦这份数据被找到了，数据接收方只要发出带有同一名字外加~\emph{LeftmostRightSibling}~注释的兴趣包即可获得后续分段。另一个办法是接收方直接计算出~\_s1~部分的名字，因为分段规则是由应用程序制定的，不是由~CCN~制定的。

正如前面例子所展示的，数据命名规则可以根据数据包的相对检索特性而专门设计。应用程序可以通过遍历树发掘存在数据。虽然这些都不属于~CCN~基本传输，但是他们都是~CCN~应用程序设计的重要组成部分。我们期待着一大批可重用的习惯的出现，期待着它们被标准化，期待着它们以共享函数库的方式实现，给应用程序开发者提供高度抽象化的模块（如文件和流媒体的传输）。

兴趣包提供了一种对已有数据的限制性查询机制。它是为高效表达接收方的下一个需求而设计的。在这里我们没有足够的篇幅去赘述我们正在研发的查询选项（query options）的细节。不够我们申明用兴趣包限制数据发布者的输出是可以做到的，不需要将整个数据集或整棵子树都发送出去。在简单排序不够用时，兴趣包还可以排除（exclude）已经收到的包。我们还在研发更高级的名字发掘机制。这些机制可以有效发掘大型子树而不一定要取得内容。

%...............................................................%
\subsection{高连通性，移动性及策略}
\label{sec:3.3}

今天的计算机通常都有多个网络接口和极强的移动性。由于~IP~只能在生成树上转发包，它很难利用多网络接口的优势，也很难适应高移动性给网络带来的变化。%为什么呢
~CCN~包不能转发成环，所以~CCN~充分利用多网络接口优势。%为什么呢
~CCN~谈论数据，而不是对节点谈话，所以它不需要把第三层的身份信息（如~IP~地址）和第二层的身份信息（如~MAC~地址）绑定在一起。即使是在连通性快速变化的情况下，~CCN~总是能够快速传输数据——物理传输有多快，~CCN~就能做到多快。再者，由于~CCN~的兴趣包和数据包是配对的，每个节点都可以获得每个名字前缀、每个~face~的细粒度性能信息。这些信息可用于动态将名字和~face~匹配（详见~\ref{sec:6.3}）。
\renewcommand\baselinestretch{1} %调一下脚注行间距
\footnote{在~IP~中，路由的不对称性通常决定了中间接地啊不可能知道某一个接口是否真的工作良好，因为路由只能看到一个对话的一个方向。}

正如~\ref{sec:2}~中说的一样，~CCN~特意用与~FIB~表项对应的~face~列表模拟了多连通性。由于缺乏能使用所有~face~的万金油式策略，设计的初衷是让每个~FIB~表项都包含一个程序。这个程序像一台抽象机器，专门负责决定怎样转发兴趣。这台机器的“指令”应该包含普通存取、算术、比较指令的子集，包含一些动作（\emph{sendToAll, sendToBest, markAsBest}）和触发器（\emph{interestSatisfied, interestTimedOut, faceDown}）。与此匹配的，~face~会有一套开放式的属性（\emph{BroadcastCapable, isContentRouter, UsageBasedCharging, PeakUseLimited}）。使用动作，属性可以被动态创建。

这些动作、触发器和属性合并在一起统称策略层（CCN Strategy Layer）。~FIB~表项中的程序就是获得这个表项所指数据的策略。我们目前的默认策略是先给所有具广播能力（\emph{BroadcastCapable}）的~face~发兴趣包，如果没有回复，则依次尝试所有其它~face。本地数据（如一场报告中报告人机器中的数据，一次商业会议中同事电脑或手机中的数据）可以直接获得。只有在本地找不到的数据才会使用路由机器去获取。

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.7\textwidth]{images/routing}
\caption{将兴趣包路由至域内多媒体内容存放处}
\label{routing}
\end{center}
\end{figure}

FIB~表项中的~face~信息可以通过各种方式获得。如图~\ref{routing}~中的数据源可以用~\emph{Register}~动作作用于本地~CCN~内核，接收对它可以提供的数据的兴趣。这么做会在本地~FIB~表中创建起相关兴趣的表项，并且会在它们后面填上对应程序的~face。已注册的名字会有一个标志位，决定它们是否应该被宣传到本地机器之外。宣传代理（announcement agent）扫描本地注册名字表，把负责他们要求的、被置位了的名字广而告之（详见~\ref{sec:5.4}）。本地扫描可以使用局限于本地名字空间的正常~CCN~兴趣包和数据包来做。广告可以使用~CCN~（即让宣传代理提供~\url{/local/CCN/registrations}），可以使用标准~IP~服务位置协议（SLP），或使用~CCN~或~IP~路由（详见~\ref{sec:4}）。%不确定

%===========================%
\section{路由}
\label{sec:4}
	\subsection{链路状态域内路由}
	\label{sec:4.1}
	
	\subsection{域间路由}
	\label{sec:4.2}

%===========================%
\section{内容为心安全}
\label{sec:5}

%...............................................................%
	\subsection{内容验证}
	\label{sec:5.1}

%...............................................................%
	\subsection{信任管理}
	\label{sec:5.2}
	
		\subsubsection{信任钥匙}
		\label{sec:5.2.1}
		
		\subsubsection{基于证据的安全}
		\label{sec:5.2.2}

%...............................................................%	
	\subsection{内容保护与访问控制}
	\label{sec:5.3}

%...............................................................%	
	\subsection{网络安全与措施强化}
	\label{sec:5.4}

%===========================%
\section{评估}
\label{sec:6}

%...............................................................%
	\subsection{数据传输的效率}
	\label{sec:6.1}
	
%...............................................................%
	\subsection{内容散布的效率}
	\label{sec:6.2}

%...............................................................%
	\subsection{VoCCN~与策略层}
	\label{sec:6.3}

%===========================%
\section{相关工作}
\label{sec:7}


%===========================%
\section{结论}
\label{sec:8}


%===========================%
\section{参考文献}
\def\tm{\leavevmode\hbox{$\rm {}^{TM}$}} %注册符 网上找的
[1] Project CCNx\tm. \url{http://www.ccnx.org}, Sep. 2009.

[2] M. Abadi. On SDSI’s Linked Local Name Spaces. \emph{Journal of Computer Security}, 6(1-2):3–21, October 1998.

[3] B. Adamson, C. Bormann, M. Handley, and J. Macker.
\emph{Multicast Negative-Acknowledgement (NACK) Building
Blocks}. IETF, November 2008. RFC 5401.

[4] W. Adjie-Winoto, E. Schwartz, H. Balakrishnan, and
J. Lilley. The Design and Implementation of an Intentional Naming System. \emph{SIGOPS Oper. Syst. Rev.}, 33(5):186–201, 1999.

[5] A. Anand, A. Gupta, A. Akella, S. Seshan, and S. Shenker. Packet Caches on Routers: The Implications of Universal Redundant Traffic Elimination. In \emph{SIGCOMM}, 2008.

[6] H. Balakrishnan, K. Lakshminarayanan, S. Ratnasamy, S. Shenker, I. Stoica, and M. Walfish. A Layered Naming Architecture for the Internet. In \emph{SIGCOMM}, 2004.

[7] M. Caesar, T. Condie, J. Kannan, K. Lakshminarayanan,
I. Stoica, and S. Shenker. ROFL: Routing on Flat Labels. In \emph{SIGCOMM}, 2006.

[8] D. Cheriton and M. Gritter. TRIAD: A New Next-Generation Internet Architecture, Jan 2000.

[9] I. Clarke, O. Sandberg, B. Wiley, and T. W. Hong. Freenet: A Distributed Anonymous Information Storage and Retrieval System. \emph{Lecture Notes in Computer Science}, 2009:46, 2001.

[10] C. M. Ellison, B. Frantz, B. Lampson, R. Rivest, B. M. Thomas, and T. Ylonen. \emph{SPKI Certificate Theory}, September 1999. RFC2693.

[11] S. Farrell and V. Cahill. \emph{Delay- and Disruption-Tolerant Networking}. Artech House Publishers, 2006.

[12] K. Fu, M. F. Kaashoek, and D. Mazières. Fast and secure distributed read-only file system. \emph{ACM Trans. Comput. Syst.}, 20(1):1–24, 2002.

[13] J. F. Gantz et al. IDC - The Expanding Digital Universe: A Forecast of Worldwide Inform ation Growth Through 2010. Technical report, March 2007.

[14] A. Gulbrandsen, P. Vixie, and L. Esibov. \emph{A DNS RR for specifying the location of services (DNS SRV)}. IETF - Network Working Group, The Internet Society, February 2000. RFC 2782.

[15] E. Guttman, C.Perkins, J. Veizades, and M. Day. \emph{Service Location Protocol}. IETF - Network Working Group, The Internet Society, June 1999. RFC 2608.

[16] IETF. RFC 2328 – OSPF Version 2.

[17] IETF. RFC 3787 – Recommendations for Interoperable IP
Networks using Intermediate System to Intermediate System (IS-IS).

[18] IETF. RFC 4971 – Intermediate System to Intermediate System (IS-IS) Extensions for Advertising Router Information.

[19] IETF. RFC 5250 – The OSPF Opaque LSA Option.

[20] V. Jacobson. Congestion Avoidance and Control. In
\emph{SIGCOMM}, 1988.

[21] V. Jacobson, R. Braden, and D. Borman. \emph{TCP Extensions for
High Performance}. IETF - Network Working Group, The
Internet Society, May 1992. RFC 1323.

[22] V. Jacobson, D. K. Smetters, N. Briggs, M. Plass, P. Stewart,
J. D. Thornton, and R. Braynard. VoCCN: Voice-over
Content-Centric Networks. In \emph{ReArch}, 2009.

[23] C. Kim, M. Caeser, and J. Rexford. Floodless in SEATTLE:
A Scalable Ethernet Architecture for Large Enterprises. In
\emph{SIGCOMM}, 2008.

[24] T. Koponen, M. Chawla, B.-G. Chun, A. Ermolinskiy, K. H.
Kim, S. Shenker, and I. Stoica. A Data-Oriented (and
Beyond) Network Architecture. In \emph{SIGCOMM}, 2007.

[25] J. Kubiatowicz et al. OceanStore: An architecture for
global-scale persistent storage. \emph{SIGPLAN Not.},
35(11):190–201, 2000.

[26] D. Mazières, M. Kaminsky, M. F. Kaashoek, and E. Witchel.
Separating Key Management from File System Security. In
\emph{SOSP}, 1999.

[27] R. C. Merkle. \emph{Secrecy, authentication, and public key
systems}. PhD thesis, 1979.

[28] R. Moskowitz and P. Nikander. \emph{Host Identity Protocol
Architecture}. IETF - Network Working Group, May 2006.
RFC 4423.

[29] B. Ohlman et al. First NetInf architecture description, April
2009. \url{http://www.4ward-project.eu/index.
php?s=file_download&id=39}.

[30] E. Osterweil, D. Massey, B. Tsendjav, B. Zhang, and
L. Zhang. Security Through Publicity. In \emph{HOTSEC}, 2006.

[31] B. C. Popescu, M. van Steen, B. Crispo, A. S. Tanenbaum,
J. Sacha, and I. Kuz. Securely replicated web documents. In
\emph{IPDPS}, 2005.

[32] R. L. Rivest and B. Lampson. SDSI - A Simple Distributed
Security Infrastructure. Technical report, MIT, 1996.

[33] M. Särelä, T. Rinta-aho, and S. Tarkoma. RTFM:
Publish/Subscribe Internetworking Architecture. In
\emph{ICT-MobileSummit}, 2008.

[34] D. K. Smetters and V. Jacobson. Securing network content,
October 2009. PARC Technical Report.

[35] I. Stoica, D. Adkins, S. Zhuang, S. Shenker, and S. Surana.
Internet Indirection Infrastructure. In \emph{SIGCOMM}, 2002.

[36] I. Stoica, R. Morris, D. Karger, F. Kaashoek, and
H. Balakrishnan. Chord: A Scalable Peer-To-Peer Lookup
Service for Internet Applications. In \emph{SIGCOMM}, 2001.

[37] D. Wendlandt, D. Andersen, and A. Perrig. Perspectives: Improving SSH-style host authentication with multi-path
probing. In \emph{USENIX}, 2008.